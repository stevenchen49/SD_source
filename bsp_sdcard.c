/*
*********************************************************************************************************
* File    : bsp_sdcard.c
* By      : chen
* Date    : 2017.8.9
*********************************************************************************************************
* Note(s) : 扇区读写最好从 10000 扇区开始
*********************************************************************************************************
*/
 
/*
*********************************************************************************************************
*                                            INCLUDE HEADER FILES
*********************************************************************************************************
*/
#include <bsp_sdcard.h>

/*
*********************************************************************************************************
*                                                CONSTANTS
*********************************************************************************************************
*/
u8   SD_Type=0;                                            /* SD卡类型                                 */

u8   SD_Sector_Clear_Array[512];                           /* SD卡扇区擦除用数组                       */

/*
*****************************************
*          调试用临时全局变量
*****************************************
*/
u8   test_return;
u8   test_cnt;
u8   test_cid[18];
u8   test_csd[18];
u8   test_sector_read[512];

u8   test_sector_write[512] = 
{
 0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,
 0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 
 0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,
 0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 
 0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
 0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 
 0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
 0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,

 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
};

u8   test_multi_sector_read[2048];
u8   test_multi_sector_write[2048] = 
{/* -------------------------------- sector 01 --------------------------------*/
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,

 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,

 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,

 /* -------------------------------- sector 02 --------------------------------*/
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,

 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,

 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,

 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 
 /* -------------------------------- sector 03 --------------------------------*/
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,

 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,

 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
};

float   test_capacity;

/*
*********************************************************************************************************
*                                           FUNCTION PROTOTYPES
*********************************************************************************************************
*/


/*
*********************************************************************************************************
*                                             SD_Card_SPI_Init
* Description : SPI 初始化函数
* Arguments   : NONE
* Returns     : NONE 
* Notes       : 
*********************************************************************************************************
*/
void   SD_Card_SPI_Init   (void)
{
	GPIO_InitTypeDef  GPIO_InitStructure;
	SPI_InitTypeDef   SPI_InitStructure;
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,  ENABLE);
	
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;

	/* SPI  MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
	GPIO_Init(GPIOB, &GPIO_InitStructure);  

	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	/* SPI  SCK pin configuration   */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_SPI2);
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_SPI2);
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_SPI2);
	
	/* SPI  NSS  pin configuration */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_12;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	
	SD_CS_DISABLE();
	
	/* SPI configuration ------------------------------------------------------- */
	SPI_I2S_DeInit(SPI2);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_Mode      = SPI_Mode_Master;
	SPI_InitStructure.SPI_DataSize  = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL      = SPI_CPOL_High;
	SPI_InitStructure.SPI_CPHA      = SPI_CPHA_2Edge;
	SPI_InitStructure.SPI_NSS       = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;
	SPI_InitStructure.SPI_FirstBit  = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_Init(SPI2,&SPI_InitStructure);
	
	SPI_Cmd(SPI2,ENABLE);
}


/*
*********************************************************************************************************
*                                             SD_Card_SPI_Init
* Description : SD_SPI 速度设置
* Arguments   : speed_set：速度设置，高速或者低速
* Returns     : NONE
* Notes       : 
*********************************************************************************************************
*/
void   SD_Card_SPI_Speed_Set   (uint8_t   speed_set)
{
	SPI_InitTypeDef   SPI_InitStructure;

	SPI_Cmd(SPI2,DISABLE);

	/* SPI configuration ------------------------------------------------------- */
	SPI_I2S_DeInit(SPI2);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_Mode      = SPI_Mode_Master;
	SPI_InitStructure.SPI_DataSize  = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL      = SPI_CPOL_High;
	SPI_InitStructure.SPI_CPHA      = SPI_CPHA_2Edge;
	SPI_InitStructure.SPI_NSS       = SPI_NSS_Soft;
	SPI_InitStructure.SPI_FirstBit  = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_Init(SPI2,&SPI_InitStructure);
	if(speed_set == SD_SPI_SPEED_HIGH){
		SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
	}else{
		SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;
	}
	SPI_Init(SPI2,&SPI_InitStructure);
	SPI_Cmd(SPI2,ENABLE);
}


/*
*********************************************************************************************************
*                                         SPI_ReadWrite_Byte
* Description : SPI读写数据
* Arguments   : txdata：待发送数据
* Returns     : rxdata: 返回数据
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SPI_ReadWriteByte   (uint8_t   txdata)
{
	uint8_t    rxdata;
	uint16_t   cnt = 0;
	
	while(SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET){
		cnt++;
		if(cnt>400) return 1;                                           /* SPI send busy               */
	}
	SPI_I2S_SendData(SPI2, txdata);

	cnt = 0;
	while(SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET){
		cnt++;
		if(cnt>400) break;
	}
	rxdata = SPI_I2S_ReceiveData(SPI2);
	return rxdata;
}


/*
*********************************************************************************************************
*                                           SD_WaitReady
* Description : 等待 SD 发送/接收完成
* Arguments   : NONE
* Returns     : 0：ERR_NONE
*               1：ERR_TIMEOUT
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_WaitReady   (void)
{
	uint8_t   rxdata;
	uint16_t  cnt;

	for(cnt=0;cnt<8000;cnt++){
		rxdata = SPI_ReadWriteByte(0xFF);
		if(rxdata != 0xFF) break;
	}

	if(cnt >= 8000) return 1;
	return 0;
}


/*
*********************************************************************************************************
*                                           SD_SendCommand
* Description : 发送指令，结束发送时关闭片选
* Arguments   : cmd：   指令
*               arg：   参数
*               crc：   校验
* Returns     : rxdata: 返回数据
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_SendCommand   (u8 cmd, u32 arg, u8 crc)
{
	unsigned char rxdata;
	unsigned char retry = 0;

	SPI_ReadWriteByte(0xff);

	SD_CS_ENABLE();

	SPI_ReadWriteByte(cmd | 0x40);   

	SPI_ReadWriteByte(arg >> 24);
	SPI_ReadWriteByte(arg >> 16);
	SPI_ReadWriteByte(arg >> 8);
	SPI_ReadWriteByte(arg);
	SPI_ReadWriteByte(crc);

	while((rxdata = SPI_ReadWriteByte(0xFF))==0xFF){
		retry++;
		if(retry > 200) break;
	}

	SD_CS_DISABLE();
	SPI_ReadWriteByte(0xFF);

	return rxdata;
}


/*
*********************************************************************************************************
*                                           SD_SendCommand_NoDeassert
* Description : 发送指令，发送结束后不关闭片选
* Arguments   : cmd：   指令
*               arg：   参数
*               crc：   校验
* Returns     : rxdata: 返回数据
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_SendCommand_NoDeassert   (u8 cmd, u32 arg, u8 crc)
{
	unsigned char rxdata;
	unsigned char retry = 0;

	SPI_ReadWriteByte(0xff);

	SD_CS_ENABLE();
	SPI_ReadWriteByte(cmd | 0x40);

	SPI_ReadWriteByte(arg >> 24);
	SPI_ReadWriteByte(arg >> 16);
	SPI_ReadWriteByte(arg >> 8);
	SPI_ReadWriteByte(arg);
	SPI_ReadWriteByte(crc);

	while((rxdata = SPI_ReadWriteByte(0xFF))==0xFF){
		retry++;
		if(retry > 200) break;
	}
	return rxdata;
}


/*
*********************************************************************************************************
*                                           SD_ReceiveData
* Description : SPI 读取指定长度的数据
* Arguments   : p_data： 数据存放地址
*               length： 数据长度
*               release：片选释放
* Returns     : 0: ERR_NONE
*               1: ERR_TIMEOUT
*               2: ERR_NO_DATA
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_ReceiveData   (uint8_t  *p_data, 
                            uint16_t  length, 
                            uint8_t   release)
{
	uint8_t    rxdata;

	uint16_t   cnt;

	SD_CS_ENABLE();

	for(cnt=0;cnt<2000;cnt++){
		rxdata = SPI_ReadWriteByte(0xFF);
		if(rxdata == 0xFE) break;
	}
	if(cnt>=2000){
		SD_CS_DISABLE();
		return 1;
	}

	for(cnt=0;cnt<length;cnt++){
		p_data[cnt] = SPI_ReadWriteByte(0xFF);
	}

	SPI_ReadWriteByte(0xFF);
	SPI_ReadWriteByte(0xFF);

	if(release){
		SD_CS_DISABLE();
		SPI_ReadWriteByte(0xFF);
	}

	return 0;
}


/*
*********************************************************************************************************
*                                              SD_GetCID
* Description : 获取 SD CID 信息如制造商等
* Arguments   : p_cid_data：用于存放CID信息的地址,需要长度16字节以上
* Returns     : 0: ERR_NONE
*               n: ERR_TIMEOUT
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_GetCID   (uint8_t  *p_cid_data)
{
	uint8_t    rxdata;

	uint16_t   cnt;

	rxdata = SD_SendCommand(CMD10, 0, 0xFF);
	if(rxdata != 0x00) return rxdata;
	
	SD_CS_ENABLE();
	
	for(cnt=0;cnt<2000;cnt++){
		rxdata = SPI_ReadWriteByte(0xFF);
		if(rxdata == 0xFF) break;
	}
	if(cnt>=2000){
		SD_CS_DISABLE();
		return 1;
	}
	rxdata = SPI_ReadWriteByte(0xFF);
	if(rxdata != 0xFF) return 2;

	for(cnt=0;cnt<18;cnt++){
		p_cid_data[cnt] = SPI_ReadWriteByte(0xFF);
	}

	SPI_ReadWriteByte(0xFF);
	SPI_ReadWriteByte(0xFF);

	SD_CS_DISABLE();
	SPI_ReadWriteByte(0xFF);

	return 0;
}


/*
*********************************************************************************************************
*                                              SD_GetCSD
* Description : 获取 SD CSD 信息如存储容量，存储速度
* Arguments   : p_csd_data：用于存放CSD信息的地址，需要长度16字节以上
* Returns     : 0: ERR_NONE
*               n: ERR_TIMEOUT
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_GetCSD   (uint8_t   *p_csd_data)
{
	uint8_t    rxdata;
	
	uint16_t   cnt;

	rxdata = SD_SendCommand(CMD9, 0, 0xFF);
	if(rxdata != 0x00) return rxdata;

	SD_CS_ENABLE();
	
	for(cnt=0;cnt<2000;cnt++){
		rxdata = SPI_ReadWriteByte(0xFF);
		if(rxdata == 0xFF) break;
	}
	if(cnt>=2000){
		SD_CS_DISABLE();
		return 1;
	}
	rxdata = SPI_ReadWriteByte(0xFF);
	if(rxdata != 0xFF) return 2;

	for(cnt=0;cnt<18;cnt++){
		p_csd_data[cnt] = SPI_ReadWriteByte(0xFF);
	}

	SPI_ReadWriteByte(0xFF);
	SPI_ReadWriteByte(0xFF);

	SD_CS_DISABLE();
	SPI_ReadWriteByte(0xFF);

	return 0;
}

/*
*********************************************************************************************************
*                                              SD_GetCapacity
* Description : 获取SD卡容量
* Arguments   : NONE
* Returns     : capacity_fp: SD卡容量，单位GB，如返回7.0             
* Notes       : 
*********************************************************************************************************
*/
float   SD_GetCapacity   (void)
{
	uint8_t    p_csd_data[20];

	uint16_t   c_size;
	uint16_t   c_size_mult;
	uint16_t   block_num;
	uint16_t   block_len;

	uint32_t   capacity;
	float      capacity_fp;

	if(SD_GetCSD(p_csd_data) != 0) return 2;

	/* ------------------------ SD_V2.0_HC ------------------------ */
	if((p_csd_data[0]&0xC0)==0x40){
		c_size = p_csd_data[9] + ((uint32_t)p_csd_data[8]<<8)+((uint32_t)(p_csd_data[7]&0x63)<<16) + 1;
		capacity = c_size<<9;


	/* -------------------------- SD_V1.0 ------------------------- */
	}else{
		c_size = p_csd_data[6]&0x03;
		c_size <<= 8;
		c_size += p_csd_data[7];
		c_size <<= 2;
		c_size += (((uint32_t)p_csd_data[8])&0xC0)>>6;

		c_size_mult = p_csd_data[9]&0x03;
		c_size_mult <<= 1;
		c_size_mult += (p_csd_data[10]&0x08)>>7;
		c_size_mult += 2;

		block_num = 1;
		while(c_size_mult){
			block_num *= 2;
			c_size_mult--;
		}
		capacity = ((uint32_t)(c_size+1))*((uint32_t)block_num);

		c_size = p_csd_data[5]&0x0F;
		block_len = 1;
		while(c_size){
			block_len *= 2;
			c_size--;
		}
		capacity *= (uint32_t)block_len;
	}
	capacity_fp = capacity/(1024.0f*1024.0f);
	return capacity_fp;

}


/*
*********************************************************************************************************
*                                           SD_Init
* Description : SD 初始化
* Arguments   : NONE
* Returns     : 0: ERR_NONE
*               1: ERR_TIMEOUT
* Notes       :              
*********************************************************************************************************
*/
uint8_t   SD_Init   (void)
{
	uint8_t   rxdata;
	uint8_t   buff[6];

	uint16_t  cnt;
	uint16_t  retry; 
	
	SD_Card_SPI_Init();
                                                                  /* SPI 初始化                        */
	for(cnt=0;cnt<0xf00;cnt++){};
	for(cnt=0;cnt<10;cnt++){
		SPI_ReadWriteByte(0xFF);
	}

	for(cnt=0;cnt<200;cnt++){                                     /* SD SPI 模式                       */
		rxdata = SD_SendCommand(CMD0, 0, 0x95);
		if(rxdata == 0x01) break;
	}
	
	if(cnt>=200) return rxdata; 
	
	rxdata = SD_SendCommand_NoDeassert(8, 0x1aa, 0x87);           /* 询问 SD 版本                      */
  
	/* ---------------------- SD 1.0 ---------------------- */
	if(rxdata == 0x05){
		SD_Type = SD_TYPE_V1;
		SD_CS_DISABLE();
		SPI_ReadWriteByte(0xFF);                                  /* 查询类型 SD or MMC                */
		
		for(cnt=0;cnt<400;cnt++){
			rxdata = SD_SendCommand(CMD55, 0, 0);
			if(rxdata != 0x01) return rxdata;
			rxdata = SD_SendCommand(ACMD41, 0, 0);
			if(rxdata == 0x00) break;
		}

		if(cnt>=400){                                             /* MMC 类型初始化                    */
			for(cnt=0;cnt<400;cnt++){
				rxdata = SD_SendCommand(1, 0, 0);
				if(rxdata == 0x00) break;
			}
			if(retry>=400) return 1;   
			SD_Type = SD_TYPE_MMC;
		}

		SD_Card_SPI_Speed_Set(SD_SPI_SPEED_HIGH);                 /* SPI 高速，配置结束开始使用 SD     */
		SPI_ReadWriteByte(0xFF);

		rxdata = SD_SendCommand(CMD16, 512, 0xff);
		if(rxdata != 0x00) return rxdata;  

	/* ---------------------- SD 2.0 ---------------------- */
	}else if(rxdata == 0x01){
		buff[0] = SPI_ReadWriteByte(0xFF);                        /* 接收CMD8命令                      */
		buff[1] = SPI_ReadWriteByte(0xFF);  
		buff[2] = SPI_ReadWriteByte(0xFF);  
		buff[3] = SPI_ReadWriteByte(0xFF);  
     
		SD_CS_DISABLE();
		SPI_ReadWriteByte(0xFF);
    
		if(buff[2]==0x01 && buff[3]==0xAA){                       /* 电压支持范围判断                  */
			for(cnt=0;cnt<200;cnt++){
				rxdata = SD_SendCommand(CMD55, 0, 0);
				if(rxdata!=0x01) return rxdata;
				rxdata = SD_SendCommand(ACMD41, 0x40000000, 0);
				if(rxdata == 0x00) break;
			}
      
			rxdata = SD_SendCommand_NoDeassert(CMD58, 0, 0);      /* 判断 SD2.0 具体版本               */
			if(rxdata!=0x00) return rxdata;  

			buff[0] = SPI_ReadWriteByte(0xFF);                    /* 获取OCR指令                       */
			buff[1] = SPI_ReadWriteByte(0xFF); 
			buff[2] = SPI_ReadWriteByte(0xFF);
			buff[3] = SPI_ReadWriteByte(0xFF);

			SD_CS_DISABLE();
			SPI_ReadWriteByte(0xFF);

			if(buff[0]&0x40){
				SD_Type = SD_TYPE_V2HC;
			}else{
				SD_Type = SD_TYPE_V2;
			}

			SD_Card_SPI_Speed_Set(SD_SPI_SPEED_HIGH);             /* SPI 高速，开始使用 SD             */
			
			for(cnt=0;cnt<0xf00;cnt++){};                         /* 延迟等待 SPI 重新配置完成         */
			SPI_ReadWriteByte(0xFF);
		}
	}


	/* ------------------------------------ test 可删除 ------------------------------------ */
	SD_GetCID(test_cid);
	SD_GetCSD(test_csd);

	test_capacity = SD_GetCapacity();

	test_return = SD_WriteSingleBlock(1,test_sector_write);
	test_return = SD_WriteSingleBlock(3,test_sector_write);

	SD_ReadSingleBlock(1,test_sector_read);
    SD_WriteMultiBlock(50000,test_multi_sector_write,3);
	SD_ReadMultiBlock(4,test_multi_sector_read,3);
	/* ------------------------------------ test 可删除 ------------------------------------ */

	return rxdata;
}


/*
*********************************************************************************************************
*                                             SD_ReadSingleBlock 
* Description : 读取SD卡的一个block块，512kB 512字节
* Arguments   : sector   ：SD卡扇区
*               p_buffer ：用于存放读取数据的数组指针
* Returns     : 0: ERR_NONE
*               n: ERR_TIMEOUT/ERR_NO_DATA
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_ReadSingleBlock   (uint32_t   sector,
                                uint8_t   *p_buffer)
{
	uint8_t   rxdata;
	uint8_t   err;

	rxdata = SD_SendCommand(CMD17, sector, 0);
	if(rxdata != 0x00) return rxdata;

	err = SD_ReceiveData(p_buffer, BLOCK_SIZE, RELEASE);
	if(err != 0x00) return err;

	return 0;
}


/*
*********************************************************************************************************
*                                              SD_WriteSingleBlock
* Description : 写一个SD的block块，512kB 512字节
* Arguments   : sector   ：SD卡扇区
*               p_buffer ：待写入数组地址指针
* Returns     : 0: ERR_NONE
*               1: ERR_TIMEOUT
*               cnt: 等待写入完成循环次数
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_WriteSingleBlock   (uint32_t   sector,
                                 uint8_t   *p_buffer)
{
	uint8_t   rxdata;
	uint16_t  cnt;

	rxdata = SD_SendCommand(CMD24, sector, 0x00);
	if(rxdata != 0x00) return rxdata;

	SD_CS_ENABLE();
	SPI_ReadWriteByte(0xff);                                   /* 等待 SD 就绪                         */
	SPI_ReadWriteByte(0xff);
	SPI_ReadWriteByte(0xff);

	SPI_ReadWriteByte(0xFE);                                   /* 起始令牌0xFE                         */

	for(cnt=0;cnt<BLOCK_SIZE;cnt++){
		SPI_ReadWriteByte(p_buffer[cnt]);
	}

	SPI_ReadWriteByte(0xff);                                   /* CRC校验位，已禁止，发送伪CRC         */
	SPI_ReadWriteByte(0xff);

	rxdata = SPI_ReadWriteByte(0xff);
	if((rxdata&0x1F)!=0x05){
		SD_CS_DISABLE();
		return rxdata;
	}

	cnt = 0;
	while(!SPI_ReadWriteByte(0xff))                            /* 等待写操作完成                       */
	{
		cnt++;
		if(cnt>4000){                                          /* 长时间写入没有完成，报错             */
			SD_CS_DISABLE();
			return 1;
		}
	}

	SD_CS_DISABLE();
	SPI_ReadWriteByte(0xff);

	if(cnt >= 4000) return 1;
	return cnt;
}


/*
*********************************************************************************************************
*                                              SD_ReadMultiBlock
* Description : 一次读取多个连续扇区的数据
* Arguments   : sector   : 读取的首个扇区的扇区号
*               p_buffer : 存储读取数据地址
*               number   : 读取块个数
* Returns     : 0: ERR_NONE
*               1: ERR_TIMEOUT
*               n: ERR_READ_FAIL_CNT
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_ReadMultiBlock   (uint32_t   sector,
                               uint8_t   *p_buffer,
                               uint8_t    number)
{
	uint8_t   rxdata;
	uint8_t   cnt;

	rxdata = SD_SendCommand(CMD18, sector, 0);
	if(rxdata != 0x00) return rxdata;

	for(cnt=0;cnt<number;cnt++){
		if(SD_ReceiveData(p_buffer, BLOCK_SIZE, NO_RELEASE) != 0x00) break;
		p_buffer += BLOCK_SIZE;
	}
	SD_SendCommand(CMD12, 0, 0);

	SD_CS_DISABLE();
	SPI_ReadWriteByte(0xFF);

	if(cnt < number) return cnt;
	return 0;
}


/*
*********************************************************************************************************
*                                              SD_WriteMultiBlock
* Description : 一次写入多个连续扇区
* Arguments   : sector   : 写入的首个扇区的扇区号
*               p_buffer : 待写入数据首地址
*               number   : 扇区个数
* Returns     : 0: ERR_NONE
*               1: ERR_TIMEOUT
*               n: ERR_WRITE_FAIL_CNT
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_WriteMultiBlock   (uint32_t   sector,
                                uint8_t   *p_buffer,
                                uint8_t    number)
{
	uint8_t   rxdata;
	uint8_t   cnt;

	uint16_t  i;

	rxdata = SD_SendCommand(CMD25, sector, 0x00);
	if(rxdata != 0x00) return rxdata;

	SD_CS_ENABLE();
	SPI_ReadWriteByte(0xff);
	SPI_ReadWriteByte(0xff);
	SPI_ReadWriteByte(0xff);

	for(cnt=0;cnt<number;cnt++){

		rxdata = SPI_ReadWriteByte(0xFC);

		for(i=0;i<BLOCK_SIZE;i++){
			rxdata = SPI_ReadWriteByte(*p_buffer++);
		}

		rxdata = SPI_ReadWriteByte(0xff);                      /* CRC校验位，已禁止，发送伪CRC         */
		rxdata = SPI_ReadWriteByte(0xff);

		rxdata = SPI_ReadWriteByte(0xff);                      /* 接收SD应答                           */

		while(!SPI_ReadWriteByte(0xff));                       /* 在SD卡忙碌时循环等待                 */
	}

	SPI_ReadWriteByte(0xFD);
	SPI_ReadWriteByte(0xff);
	while(!SPI_ReadWriteByte(0xff));

	SD_CS_DISABLE();

	return 0;
}


/*
*********************************************************************************************************
*                                              SD_SectorClear
* Description : 目标扇区清除
* Arguments   : sector：目标扇区
* Returns     : cnt   ：清除所用循环计数
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_SectorClear   (uint32_t   sector)
{
	uint16_t   cnt;

	cnt = SD_WriteSingleBlock(sector,SD_Sector_Clear_Array);
	return cnt;
}


