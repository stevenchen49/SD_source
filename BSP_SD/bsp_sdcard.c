
/*
*********************************************************************************************************
* File    : bsp_sdcard.c
* By      : chen
* Date    : 2017.8.9
*********************************************************************************************************
* Note(s) : 扇区读写最好从 10000 扇区开始
*********************************************************************************************************
*/
 
/*
*********************************************************************************************************
*                                            INCLUDE HEADER FILES
*********************************************************************************************************
*/
#include <bsp_sdcard.h>

/*
*********************************************************************************************************
*                                                CONSTANTS
*********************************************************************************************************
*/
uint8_t    SD_Type=0;                                     /* SD卡类型                                 */

uint8_t    SD_Sector_Clear_Array[512];                    /* SD卡扇区擦除用数组                       */

uint8_t    SD_CID_Data[18];                               /* SD_CID 信息                              */
uint8_t    SD_CSD_Data[18];                               /* SD_CSD 信息                              */

uint8_t    SD_Read_Buffer[512];

DWORD      SD_Total_Capacity;                             /* SD 总容量 KB                             */
DWORD      SD_Free_Capacity;                              /* SD 可用容量 KB                           */

FATFS      SD_FATFS;

FIL        File_Creat;

FIL        File_Read_Pre;
FIL        File_Read;

FIL        File_Write_Pre;
FIL        File_Write;

RTC_DateTypeDef rtc_data;
RTC_TimeTypeDef rtc_time;
/*
*****************************************
*          调试用临时全局变量
*****************************************
*/
u8   test_return;
u8   test_cnt;
u8   test_cid[18];
u8   test_csd[18];
u8   test_sector_read[512];

u8   test_sector_write[512] = 
{
 0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,
 0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 
 0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,
 0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 
 0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
 0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 
 0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
 0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,

 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
};

u8   test_multi_sector_read[2048];
u8   test_multi_sector_write[2048] = 
{/* -------------------------------- sector 01 --------------------------------*/
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,

 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,

 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,

 /* -------------------------------- sector 02 --------------------------------*/
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,

 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,

 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,

 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 
 /* -------------------------------- sector 03 --------------------------------*/
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,

 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
 
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,

 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
};

float     test_capacity;

uint8_t   test_File_Write[200] = {
	"Date: 2017.8.17\r\n"
	"Time: 21:04 PM\r\n"
	"时间\t\t俯仰\t\t滚转\t\t航向\r\n"
};

uint8_t   test_file_name[20] = {
	"my_test_01.txt"
};
/*
*********************************************************************************************************
*                                           FUNCTION PROTOTYPES
*********************************************************************************************************
*/


/*
*********************************************************************************************************
*                                             SD_Card_SPI_Init
* Description : SPI 初始化函数
* Arguments   : NONE
* Returns     : NONE 
* Notes       : 
*********************************************************************************************************
*/
void   SD_Card_SPI_Init   (void)
{
	GPIO_InitTypeDef  GPIO_InitStructure;
	SPI_InitTypeDef   SPI_InitStructure;
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,  ENABLE);
	
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;

	/* SPI  MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
	GPIO_Init(GPIOB, &GPIO_InitStructure);  

	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	/* SPI  SCK pin configuration   */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_SPI2);
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_SPI2);
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_SPI2);
	
	/* SPI  NSS  pin configuration */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_12;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	
	SD_CS_DISABLE();
	
	/* SPI configuration ------------------------------------------------------- */
	SPI_I2S_DeInit(SPI2);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_Mode      = SPI_Mode_Master;
	SPI_InitStructure.SPI_DataSize  = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL      = SPI_CPOL_High;
	SPI_InitStructure.SPI_CPHA      = SPI_CPHA_2Edge;
	SPI_InitStructure.SPI_NSS       = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;
	SPI_InitStructure.SPI_FirstBit  = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_Init(SPI2,&SPI_InitStructure);
	
	SPI_Cmd(SPI2,ENABLE);
}


/*
*********************************************************************************************************
*                                             SD_Card_SPI_Init
* Description : SD_SPI 速度设置
* Arguments   : speed_set：速度设置，高速或者低速
* Returns     : NONE
* Notes       : 
*********************************************************************************************************
*/
void   SD_Card_SPI_Speed_Set   (uint8_t   speed_set)
{
	SPI_InitTypeDef   SPI_InitStructure;

	SPI_Cmd(SPI2,DISABLE);

	/* SPI configuration ------------------------------------------------------- */
	SPI_I2S_DeInit(SPI2);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_Mode      = SPI_Mode_Master;
	SPI_InitStructure.SPI_DataSize  = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL      = SPI_CPOL_High;
	SPI_InitStructure.SPI_CPHA      = SPI_CPHA_2Edge;
	SPI_InitStructure.SPI_NSS       = SPI_NSS_Soft;
	SPI_InitStructure.SPI_FirstBit  = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_Init(SPI2,&SPI_InitStructure);
	if(speed_set == SD_SPI_SPEED_HIGH){
		SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
	}else{
		SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;
	}
	SPI_Init(SPI2,&SPI_InitStructure);
	SPI_Cmd(SPI2,ENABLE);
}


/*
*********************************************************************************************************
*                                         SPI_ReadWrite_Byte
* Description : SPI读写数据
* Arguments   : txdata：待发送数据
* Returns     : rxdata: 返回数据
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SPI_ReadWriteByte   (uint8_t   txdata)
{
	uint8_t    rxdata;
	uint16_t   cnt = 0;
	
	while(SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET){
		cnt++;
		if(cnt>400) return 1;                                           /* SPI send busy               */
	}
	SPI_I2S_SendData(SPI2, txdata);

	cnt = 0;
	while(SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET){
		cnt++;
		if(cnt>400) break;
	}
	rxdata = SPI_I2S_ReceiveData(SPI2);
	return rxdata;
}


/*
*********************************************************************************************************
*                                           SD_WaitReady
* Description : 等待 SD 发送/接收完成
* Arguments   : NONE
* Returns     : SD_ERR_NONE
*               SD_ERR_TIMEOUT
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_WaitReady   (void)
{
	uint8_t   rxdata;
	uint16_t  cnt;

	for(cnt=0;cnt<8000;cnt++){
		rxdata = SPI_ReadWriteByte(0xFF);
		if(rxdata != 0xFF) break;
	}

	if(cnt >= 8000) return SD_ERR_TIMEOUT;
	return SD_ERR_NONE;
}


/*
*********************************************************************************************************
*                                           SD_SendCommand
* Description : 发送指令，结束发送时关闭片选
* Arguments   : cmd：   指令
*               arg：   参数
*               crc：   校验
* Returns     : rxdata: 返回数据
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_SendCommand   (u8 cmd, u32 arg, u8 crc)
{
	unsigned char rxdata;
	unsigned char retry = 0;

	SPI_ReadWriteByte(0xff);

	SD_CS_ENABLE();

	SPI_ReadWriteByte(cmd | 0x40);   

	SPI_ReadWriteByte(arg >> 24);
	SPI_ReadWriteByte(arg >> 16);
	SPI_ReadWriteByte(arg >> 8);
	SPI_ReadWriteByte(arg);
	SPI_ReadWriteByte(crc);

	while((rxdata = SPI_ReadWriteByte(0xFF))==0xFF){
		retry++;
		if(retry > 200){
			SD_CS_DISABLE();
			return SD_ERR_TIMEOUT;
		}
	}

	SD_CS_DISABLE();
	SPI_ReadWriteByte(0xFF);

	return rxdata;
}


/*
*********************************************************************************************************
*                                           SD_SendCommand_NoDeassert
* Description : 发送指令，发送结束后不关闭片选
* Arguments   : cmd：   指令
*               arg：   参数
*               crc：   校验
* Returns     : rxdata: 返回数据
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_SendCommand_NoDeassert   (u8 cmd, u32 arg, u8 crc)
{
	unsigned char rxdata;
	unsigned char retry = 0;

	SPI_ReadWriteByte(0xff);

	SD_CS_ENABLE();
	SPI_ReadWriteByte(cmd | 0x40);

	SPI_ReadWriteByte(arg >> 24);
	SPI_ReadWriteByte(arg >> 16);
	SPI_ReadWriteByte(arg >> 8);
	SPI_ReadWriteByte(arg);
	SPI_ReadWriteByte(crc);

	while((rxdata = SPI_ReadWriteByte(0xFF))==0xFF){
		retry++;
		if(retry > 200){
			SD_CS_DISABLE();
			return SD_ERR_TIMEOUT;
		}
	}
	return rxdata;
}


/*
*********************************************************************************************************
*                                           SD_ReceiveData
* Description : SPI 读取指定长度的数据
* Arguments   : p_data： 数据存放地址
*               length： 数据长度
*               release：片选释放
* Returns     : SD_ERR_NONE
*               SD_ERR_TIMEOUT
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_ReceiveData   (uint8_t  *p_data, 
                            uint16_t  length, 
                            uint8_t   release)
{
	uint8_t    rxdata;

	uint16_t   cnt;

	SD_CS_ENABLE();

	for(cnt=0;cnt<2000;cnt++){
		rxdata = SPI_ReadWriteByte(0xFF);
		if(rxdata == 0xFE) break;
	}
	if(cnt>=2000){
		SD_CS_DISABLE();
		return SD_ERR_TIMEOUT;
	}

	for(cnt=0;cnt<length;cnt++){
		p_data[cnt] = SPI_ReadWriteByte(0xFF);
	}

	SPI_ReadWriteByte(0xFF);
	SPI_ReadWriteByte(0xFF);

	if(release){
		SD_CS_DISABLE();
		SPI_ReadWriteByte(0xFF);
	}

	return SD_ERR_NONE;
}


/*
*********************************************************************************************************
*                                              SD_GetCID
* Description : 获取 SD CID 信息如制造商等
* Arguments   : p_cid_data：用于存放CID信息的地址,需要长度16字节以上
* Returns     : SD_ERR_NONE
*               SD_ERR_TIMEOUT
*               SD_ERR_RESPONSE_FAILURE
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_GetCID   (uint8_t  *p_cid_data)
{
	uint8_t    rxdata;

	uint16_t   cnt;

	rxdata = SD_SendCommand(CMD10, 0, 0xFF);
	if(rxdata != 0x00) return SD_ERR_RESPONSE_FAILURE;
	
	SD_CS_ENABLE();
	
	for(cnt=0;cnt<2000;cnt++){
		rxdata = SPI_ReadWriteByte(0xFF);
		if(rxdata == 0xFF) break;
	}
	if(cnt>=2000){
		SD_CS_DISABLE();
		return SD_ERR_TIMEOUT;
	}
	rxdata = SPI_ReadWriteByte(0xFF);
	if(rxdata != 0xFF) return SD_ERR_RESPONSE_FAILURE;

	for(cnt=0;cnt<18;cnt++){
		p_cid_data[cnt] = SPI_ReadWriteByte(0xFF);
	}

	SPI_ReadWriteByte(0xFF);
	SPI_ReadWriteByte(0xFF);

	SD_CS_DISABLE();
	SPI_ReadWriteByte(0xFF);

	return SD_ERR_NONE;
}


/*
*********************************************************************************************************
*                                              SD_GetCSD
* Description : 获取 SD CSD 信息如存储容量，存储速度
* Arguments   : p_csd_data：用于存放CSD信息的地址，需要长度16字节以上
* Returns     : SD_ERR_NONE
*               SD_ERR_TIMEOUT
*               SD_ERR_RESPONSE_FAILURE
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_GetCSD   (uint8_t   *p_csd_data)
{
	uint8_t    rxdata;
	
	uint16_t   cnt;

	rxdata = SD_SendCommand(CMD9, 0, 0xFF);
	if(rxdata != 0x00) return SD_ERR_RESPONSE_FAILURE;

	SD_CS_ENABLE();
	
	for(cnt=0;cnt<2000;cnt++){
		rxdata = SPI_ReadWriteByte(0xFF);
		if(rxdata == 0xFF) break;
	}
	if(cnt>=2000){
		SD_CS_DISABLE();
		return SD_ERR_TIMEOUT;
	}
	rxdata = SPI_ReadWriteByte(0xFF);
	if(rxdata != 0xFF) return SD_ERR_RESPONSE_FAILURE;

	for(cnt=0;cnt<18;cnt++){
		p_csd_data[cnt] = SPI_ReadWriteByte(0xFF);
	}

	SPI_ReadWriteByte(0xFF);
	SPI_ReadWriteByte(0xFF);

	SD_CS_DISABLE();
	SPI_ReadWriteByte(0xFF);

	return SD_ERR_NONE;
}

/*
*********************************************************************************************************
*                                              SD_GetCapacity
* Description : 获取SD卡容量
* Arguments   : NONE
* Returns     : capacity_fp: SD卡容量，单位GB，如返回7.0      
*               SD_ERR_RESPONSE_FAILURE
* Notes       : 
*********************************************************************************************************
*/
float   SD_GetCapacity   (void)
{
	uint8_t    p_csd_data[20];

	uint16_t   c_size;
	uint16_t   c_size_mult;
	uint16_t   block_num;
	uint16_t   block_len;

	uint32_t   capacity;
	float      capacity_fp;

	if(SD_GetCSD(p_csd_data) != 0) return SD_ERR_RESPONSE_FAILURE;

	/* ------------------------ SD_V2.0_HC ------------------------ */
	if((p_csd_data[0]&0xC0)==0x40){
		c_size = p_csd_data[9] + ((uint32_t)p_csd_data[8]<<8)+((uint32_t)(p_csd_data[7]&0x63)<<16) + 1;
		capacity = c_size<<9;

	/* -------------------------- SD_V1.0 ------------------------- */
	}else{
		c_size = p_csd_data[6]&0x03;
		c_size <<= 8;
		c_size += p_csd_data[7];
		c_size <<= 2;
		c_size += (((uint32_t)p_csd_data[8])&0xC0)>>6;

		c_size_mult = p_csd_data[9]&0x03;
		c_size_mult <<= 1;
		c_size_mult += (p_csd_data[10]&0x08)>>7;
		c_size_mult += 2;

		block_num = 1;
		while(c_size_mult){
			block_num *= 2;
			c_size_mult--;
		}
		capacity = ((uint32_t)(c_size+1))*((uint32_t)block_num);

		c_size = p_csd_data[5]&0x0F;
		block_len = 1;
		while(c_size){
			block_len *= 2;
			c_size--;
		}
		capacity *= (uint32_t)block_len;
	}
	capacity_fp = capacity/(1024.0f*1024.0f);
	return capacity_fp;

}


/*
*********************************************************************************************************
*                                           SD_Init
* Description : SD 初始化
* Arguments   : NONE
* Returns     : SD_ERR_NONE
*               SD_ERR_TIMEOUT
*               SD_ERR_RESPONSE_FAILURE
* Notes       :              
*********************************************************************************************************
*/
uint8_t   SD_Init   (void)
{
	uint8_t   rxdata;
	uint8_t   buff[6];

	uint16_t  cnt;
	uint16_t  retry; 
	
	SD_Card_SPI_Init();
                                                                  /* SPI 初始化                        */
	for(cnt=0;cnt<0xf00;cnt++){};
	for(cnt=0;cnt<10;cnt++){
		SPI_ReadWriteByte(0xFF);
	}

	for(cnt=0;cnt<200;cnt++){                                     /* SD SPI 模式                       */
		rxdata = SD_SendCommand(CMD0, 0, 0x95);
		if(rxdata == 0x01) break;
	}
	
	if(cnt>=200) return SD_ERR_TIMEOUT; 
	
	rxdata = SD_SendCommand_NoDeassert(8, 0x1aa, 0x87);           /* 询问 SD 版本                      */
  
	/* ---------------------- SD 1.0 ---------------------- */
	if(rxdata == 0x05){
		SD_Type = SD_TYPE_V1;
		SD_CS_DISABLE();
		SPI_ReadWriteByte(0xFF);                                  /* 查询类型 SD or MMC                */
		
		for(cnt=0;cnt<400;cnt++){
			rxdata = SD_SendCommand(CMD55, 0, 0);
			if(rxdata != 0x01) return SD_ERR_RESPONSE_FAILURE;
			rxdata = SD_SendCommand(ACMD41, 0, 0);
			if(rxdata == 0x00) break;
		}

		if(cnt>=400){                                             /* MMC 类型初始化                    */
			for(cnt=0;cnt<400;cnt++){
				rxdata = SD_SendCommand(1, 0, 0);
				if(rxdata == 0x00) break;
			}
			if(retry>=400) return SD_ERR_TIMEOUT;   
			SD_Type = SD_TYPE_MMC;
		}

		SD_Card_SPI_Speed_Set(SD_SPI_SPEED_HIGH);                 /* SPI 高速，配置结束开始使用 SD     */
		SPI_ReadWriteByte(0xFF);

		rxdata = SD_SendCommand(CMD16, 512, 0xff);
		if(rxdata != 0x00) return SD_ERR_RESPONSE_FAILURE;  

	/* ---------------------- SD 2.0 ---------------------- */
	}else if(rxdata == 0x01){
		buff[0] = SPI_ReadWriteByte(0xFF);                        /* 接收CMD8命令                      */
		buff[1] = SPI_ReadWriteByte(0xFF);  
		buff[2] = SPI_ReadWriteByte(0xFF);  
		buff[3] = SPI_ReadWriteByte(0xFF);  

		SD_CS_DISABLE();
		SPI_ReadWriteByte(0xFF);
    
		if(buff[2]==0x01 && buff[3]==0xAA){                       /* 电压支持范围判断                  */
			for(cnt=0;cnt<200;cnt++){
				rxdata = SD_SendCommand(CMD55, 0, 0);
				if(rxdata!=0x01) return SD_ERR_RESPONSE_FAILURE;
				rxdata = SD_SendCommand(ACMD41, 0x40000000, 0);
				if(rxdata == 0x00) break;
			}
      
			rxdata = SD_SendCommand_NoDeassert(CMD58, 0, 0);      /* 判断 SD2.0 具体版本               */
			if(rxdata!=0x00) return SD_ERR_RESPONSE_FAILURE;  

			buff[0] = SPI_ReadWriteByte(0xFF);                    /* 获取OCR指令                       */
			buff[1] = SPI_ReadWriteByte(0xFF); 
			buff[2] = SPI_ReadWriteByte(0xFF);
			buff[3] = SPI_ReadWriteByte(0xFF);

			SD_CS_DISABLE();
			SPI_ReadWriteByte(0xFF);

			if(buff[0]&0x40){
				SD_Type = SD_TYPE_V2HC;
			}else{
				SD_Type = SD_TYPE_V2;
			}

			SD_Card_SPI_Speed_Set(SD_SPI_SPEED_HIGH);             /* SPI 高速，开始使用 SD             */
			
			for(cnt=0;cnt<0xf00;cnt++){};                         /* 延迟等待 SPI 重新配置完成         */
			SPI_ReadWriteByte(0xFF);
		}
	}

	SD_GetCID(SD_CID_Data);
	SD_GetCSD(SD_CSD_Data);

	/* ------------------------------------ test 可删除 ------------------------------------ */
	test_capacity = SD_GetCapacity();

	test_return = SD_WriteSingleBlock(1,test_sector_write);
	test_return = SD_WriteSingleBlock(3,test_sector_write);

	test_return = SD_ReadSingleBlock(3,test_sector_read);
	test_return = SD_WriteMultiBlock(50000,test_multi_sector_write,3);
	test_return = SD_ReadMultiBlock(4,test_multi_sector_read,3);
	/* ------------------------------------ test 可删除 ------------------------------------ */

	return SD_ERR_NONE;
}


/*
*********************************************************************************************************
*                                             SD_ReadSingleBlock 
* Description : 读取SD卡的一个block块，512kB 512字节
* Arguments   : sector   ：SD卡扇区
*               p_buffer ：用于存放读取数据的数组指针
* Returns     : SD_ERR_NONE
*               SD_ERR_RESPONSE_FAILURE
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_ReadSingleBlock   (uint32_t   sector,
                                uint8_t   *p_buffer)
{
	uint8_t   rxdata;
	uint8_t   err;

	rxdata = SD_SendCommand(CMD17, sector, 0);
	if(rxdata != 0x00) return SD_ERR_RESPONSE_FAILURE;

	err = SD_ReceiveData(p_buffer, BLOCK_SIZE, RELEASE);
	if(err != 0x00) return SD_ERR_RESPONSE_FAILURE;

	return SD_ERR_NONE;
}


/*
*********************************************************************************************************
*                                              SD_WriteSingleBlock
* Description : 写一个SD的block块，512kB 512字节
* Arguments   : sector   ：SD卡扇区
*               p_buffer ：待写入数组地址指针
* Returns     : SD_ERR_NONE
*               SD_ERR_TIMEOUT
*               SD_ERR_RESPONSE_FAILURE
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_WriteSingleBlock   (uint32_t   sector,
                                 uint8_t   *p_buffer)
{
	uint8_t   rxdata;
	uint16_t  cnt;

	rxdata = SD_SendCommand(CMD24, sector, 0x00);
	if(rxdata != 0x00) return SD_ERR_RESPONSE_FAILURE;

	SD_CS_ENABLE();
	SPI_ReadWriteByte(0xff);                                   /* 等待 SD 就绪                         */
	SPI_ReadWriteByte(0xff);
	SPI_ReadWriteByte(0xff);

	SPI_ReadWriteByte(0xFE);                                   /* 起始令牌0xFE                         */

	for(cnt=0;cnt<BLOCK_SIZE;cnt++){
		SPI_ReadWriteByte(p_buffer[cnt]);
	}

	SPI_ReadWriteByte(0xff);                                   /* CRC校验位，已禁止，发送伪CRC         */
	SPI_ReadWriteByte(0xff);

	rxdata = SPI_ReadWriteByte(0xff);
	if((rxdata&0x1F)!=0x05){
		SD_CS_DISABLE();
		return SD_ERR_RESPONSE_FAILURE;
	}

	cnt = 0;
	while(!SPI_ReadWriteByte(0xff))                            /* 等待写操作完成                       */
	{
		cnt++;
		if(cnt>4000){                                          /* 长时间写入没有完成，报错             */
			SD_CS_DISABLE();
			return SD_ERR_TIMEOUT;
		}
	}

	SD_CS_DISABLE();
	SPI_ReadWriteByte(0xff);

	if(cnt >= 4000) return SD_ERR_TIMEOUT;
	return SD_ERR_NONE;
}


/*
*********************************************************************************************************
*                                              SD_ReadMultiBlock
* Description : 一次读取多个连续扇区的数据
* Arguments   : sector   : 读取的首个扇区的扇区号
*               p_buffer : 存储读取数据地址
*               number   : 读取块个数
* Returns     : SD_ERR_NONE
*               SD_ERR_TIMEOUT
*               SD_ERR_RESPONSE_FAILURE
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_ReadMultiBlock   (uint32_t   sector,
                               uint8_t   *p_buffer,
                               uint8_t    number)
{
	uint8_t   rxdata;
	uint8_t   cnt;

	rxdata = SD_SendCommand(CMD18, sector, 0);
	if(rxdata != 0x00) return SD_ERR_RESPONSE_FAILURE;

	for(cnt=0;cnt<number;cnt++){
		if(SD_ReceiveData(p_buffer, BLOCK_SIZE, NO_RELEASE) != 0x00) break;
		p_buffer += BLOCK_SIZE;
	}
	SD_SendCommand(CMD12, 0, 0);

	SD_CS_DISABLE();
	SPI_ReadWriteByte(0xFF);

	if(cnt < number) return SD_ERR_RESPONSE_FAILURE;
	return SD_ERR_NONE;
}


/*
*********************************************************************************************************
*                                              SD_WriteMultiBlock
* Description : 一次写入多个连续扇区
* Arguments   : sector   : 写入的首个扇区的扇区号
*               p_buffer : 待写入数据首地址
*               number   : 扇区个数
* Returns     : SD_ERR_NONE
*               SD_ERR_TIMEOUT
*               SD_ERR_RESPONSE_FAILURE
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_WriteMultiBlock   (uint32_t   sector,
                                uint8_t   *p_buffer,
                                uint8_t    number)
{
	uint8_t   rxdata;
	uint8_t   cnt;

	uint16_t  cnt_timeout = 0;
	uint16_t  i;

	rxdata = SD_SendCommand(CMD25, sector, 0x00);
	if(rxdata != 0x00) return SD_ERR_RESPONSE_FAILURE;

	SD_CS_ENABLE();
	SPI_ReadWriteByte(0xff);
	SPI_ReadWriteByte(0xff);
	SPI_ReadWriteByte(0xff);

	for(cnt=0;cnt<number;cnt++){

		rxdata = SPI_ReadWriteByte(0xFC);

		for(i=0;i<BLOCK_SIZE;i++){
			rxdata = SPI_ReadWriteByte(*p_buffer++);
		}

		rxdata = SPI_ReadWriteByte(0xff);                      /* CRC校验位，已禁止，发送伪CRC         */
		rxdata = SPI_ReadWriteByte(0xff);

		rxdata = SPI_ReadWriteByte(0xff);                      /* 接收SD应答                           */

		while(!SPI_ReadWriteByte(0xff)){
			cnt_timeout++;
			if(cnt_timeout >= 2000){
				SD_CS_DISABLE();
				return SD_ERR_TIMEOUT;
			}
		}
	}

	SPI_ReadWriteByte(0xFD);
	SPI_ReadWriteByte(0xff);
    
	cnt_timeout = 0;
	while(!SPI_ReadWriteByte(0xff)){
		cnt_timeout++;
		if(cnt_timeout >= 2000){
			SD_CS_DISABLE();
			return SD_ERR_TIMEOUT;
		}
	}

	SD_CS_DISABLE();

	return SD_ERR_NONE;
}


/*
*********************************************************************************************************
*                                              SD_SectorClear
* Description : 目标扇区清除
* Arguments   : sector：目标扇区
* Returns     : SD_ERR_NONE
*               SD_ERR_TIMEOUT
*               SD_ERR_RESPONSE_FAILURE
* Notes       : 
*********************************************************************************************************
*/
uint8_t   SD_SectorClear   (uint32_t   sector)
{
	uint8_t   err;

	err = SD_WriteSingleBlock(sector,SD_Sector_Clear_Array);
	return err;
}


/*
*********************************************************************************************************
*                                               FAT Filesystem
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*                                              SD_FATFS_Init
* Description : SD FATFS 文件系统启动
* Arguments   : total ：存放 SD 总容量的变量地址
*               free  ；存放 SD 可用容量的变量地址
* Returns     : res   : 函数运行结果 FRESULT 枚举类型
* Notes       : 
*********************************************************************************************************
*/
FRESULT   SD_FATFS_Init   (DWORD  *total,
                           DWORD  *free)
{
	FRESULT   res;
	DWORD     free_clusters;
	DWORD     total_sector;
	DWORD     free_sector;
	FATFS    *p_fs;

	res = f_mount(&SD_FATFS,"",1);
	if(res != FR_OK) return res;

	res = f_getfree("",&free_clusters,&p_fs);
	if(res == FR_OK){
		total_sector = (p_fs->n_fatent-2)*(p_fs->csize); ///< 总扇区数
		free_sector  = free_clusters*(p_fs->csize);      ///< 空闲扇区数
		*total = total_sector>>1;
		*free  = free_sector>>1;
	}

	SD_FATFS_Creat_File((char*)test_file_name);
	SD_FATFS_Write_File("create.txt",test_File_Write);

	return res;
}


/*
*********************************************************************************************************
*                                              SD_FATFS_Creat_File
* Description : 创建文件，并写入文件名
* Arguments   : path : 文件路径
* Returns     : res  : 返回错误类型，具体见 FRESULT 枚举类型
* Notes       : 
*********************************************************************************************************
*/
FRESULT   SD_FATFS_Creat_File   (TCHAR  *path)
{
	FRESULT   res;
	UINT      btw;
	UINT      br;

	res = f_open(&File_Creat,path,FA_CREATE_ALWAYS | FA_WRITE);
	if(res != FR_OK) return res;
	btw = strlen(path);
	res = f_write(&File_Creat,path,btw,&br);
	if(res != FR_OK) return res;
	res = f_close(&File_Creat);
	return res;
}


/*
*********************************************************************************************************
*                                              SD_FATFS_Read_File
* Description : 读取文件
* Arguments   : path     : 文件路径
*               p_buff   : 存放缓存
*               buff_len : 缓存大小
* Returns     : res      : 返回错误类型，具体见 FRESULT 枚举类型
* Notes       : 
*********************************************************************************************************
*/
FRESULT   SD_FATFS_Read_File   (TCHAR     *path,
                                uint8_t   *p_buff,
                                uint32_t   buff_len)
{
	FRESULT   res;
	UINT      br;

	res = f_open(&File_Read,path,FA_READ|FA_OPEN_EXISTING);
	if(res != FR_OK) return res;
	res = f_read(&File_Read,p_buff,buff_len,&br);
	if(res != FR_OK) return res;
	res = f_close(&File_Read);
	return res;
}


/*
*********************************************************************************************************
*                                              SD_FATFS_Write_File
* Description : 写入文件,从头开始写，会覆盖原有数据
* Arguments   : path   : 文件路径
*               p_buff ：指向待写入数据
* Returns     : res    : 返回错误类型，具体见 FRESULT 枚举类型
* Notes       : 
*********************************************************************************************************
*/
FRESULT   SD_FATFS_Write_File   (TCHAR  *path,
                                 void   *p_buff)
{
	FRESULT   res;
	UINT      btw;
	UINT      br;

	res = f_open(&File_Write,path,FA_CREATE_ALWAYS | FA_WRITE);
	if(res != FR_OK) return res;
	btw = strlen(p_buff);
	res = f_write(&File_Write,p_buff,btw,&br);
	if(res != FR_OK) return res;
	res = f_close(&File_Write);
	return res;
}


/*
*********************************************************************************************************
*                                             
* Description : 
* Arguments   : 
* Returns     : 
* Notes       : 
*********************************************************************************************************
*/
FRESULT   SD_Write_Data   (TCHAR     *path,
                           void      *p_buff,
                           uint32_t   buff_len,
                           uint8_t    type)
{
	FRESULT   res;
	FSIZE_t   fptr;
	UINT      btw;
	UINT      br;
	char      str[16] = {0,0};
	uint32_t  cnt;

	res = f_open(&File_Write,path, FA_WRITE | FA_READ);
	if(res != FR_OK) return res;
	res = f_sync(&File_Write);

	for(cnt=0;cnt<buff_len;cnt++){
		if(type == SD_DATA_TYPE_DEC){
			sprintf(str,"%d",((int*)p_buff)[cnt]);
		}else if(type == SD_DATA_TYPE_HEX){
			sprintf(str,"%x",((int*)p_buff)[cnt]);
		}else if(type == SD_DATA_TYPE_FP){
			sprintf(str,"%.6lf",((float)((int*)p_buff)[cnt]));
		}else {
			return FR_INVALID_PARAMETER;
		}
		btw = sizeof(str);
		fptr = f_size(&File_Write);
		res = f_lseek(&File_Write,fptr);
		if(res != FR_OK) return res;
		res = f_write(&File_Write,str,btw,&br);
		if(res != FR_OK) return res;
	}

	File_Write_Pre = File_Write;
	res = f_close(&File_Write);
	return res;
}





